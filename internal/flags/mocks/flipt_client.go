// Code generated by mockery v2.23.0. DO NOT EDIT.

package mocks

import (
	context "context"

	flipt "go.flipt.io/flipt-grpc"
	emptypb "google.golang.org/protobuf/types/known/emptypb"

	grpc "google.golang.org/grpc"

	mock "github.com/stretchr/testify/mock"
)

// FliptClient is an autogenerated mock type for the FliptClient type
type FliptClient struct {
	mock.Mock
}

// BatchEvaluate provides a mock function with given fields: ctx, in, opts
func (_m *FliptClient) BatchEvaluate(ctx context.Context, in *flipt.BatchEvaluationRequest, opts ...grpc.CallOption) (*flipt.BatchEvaluationResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flipt.BatchEvaluationResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.BatchEvaluationRequest, ...grpc.CallOption) (*flipt.BatchEvaluationResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.BatchEvaluationRequest, ...grpc.CallOption) *flipt.BatchEvaluationResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flipt.BatchEvaluationResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *flipt.BatchEvaluationRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateConstraint provides a mock function with given fields: ctx, in, opts
func (_m *FliptClient) CreateConstraint(ctx context.Context, in *flipt.CreateConstraintRequest, opts ...grpc.CallOption) (*flipt.Constraint, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flipt.Constraint
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.CreateConstraintRequest, ...grpc.CallOption) (*flipt.Constraint, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.CreateConstraintRequest, ...grpc.CallOption) *flipt.Constraint); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flipt.Constraint)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *flipt.CreateConstraintRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateDistribution provides a mock function with given fields: ctx, in, opts
func (_m *FliptClient) CreateDistribution(ctx context.Context, in *flipt.CreateDistributionRequest, opts ...grpc.CallOption) (*flipt.Distribution, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flipt.Distribution
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.CreateDistributionRequest, ...grpc.CallOption) (*flipt.Distribution, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.CreateDistributionRequest, ...grpc.CallOption) *flipt.Distribution); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flipt.Distribution)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *flipt.CreateDistributionRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFlag provides a mock function with given fields: ctx, in, opts
func (_m *FliptClient) CreateFlag(ctx context.Context, in *flipt.CreateFlagRequest, opts ...grpc.CallOption) (*flipt.Flag, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flipt.Flag
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.CreateFlagRequest, ...grpc.CallOption) (*flipt.Flag, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.CreateFlagRequest, ...grpc.CallOption) *flipt.Flag); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flipt.Flag)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *flipt.CreateFlagRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRule provides a mock function with given fields: ctx, in, opts
func (_m *FliptClient) CreateRule(ctx context.Context, in *flipt.CreateRuleRequest, opts ...grpc.CallOption) (*flipt.Rule, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flipt.Rule
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.CreateRuleRequest, ...grpc.CallOption) (*flipt.Rule, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.CreateRuleRequest, ...grpc.CallOption) *flipt.Rule); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flipt.Rule)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *flipt.CreateRuleRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSegment provides a mock function with given fields: ctx, in, opts
func (_m *FliptClient) CreateSegment(ctx context.Context, in *flipt.CreateSegmentRequest, opts ...grpc.CallOption) (*flipt.Segment, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flipt.Segment
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.CreateSegmentRequest, ...grpc.CallOption) (*flipt.Segment, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.CreateSegmentRequest, ...grpc.CallOption) *flipt.Segment); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flipt.Segment)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *flipt.CreateSegmentRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateVariant provides a mock function with given fields: ctx, in, opts
func (_m *FliptClient) CreateVariant(ctx context.Context, in *flipt.CreateVariantRequest, opts ...grpc.CallOption) (*flipt.Variant, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flipt.Variant
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.CreateVariantRequest, ...grpc.CallOption) (*flipt.Variant, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.CreateVariantRequest, ...grpc.CallOption) *flipt.Variant); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flipt.Variant)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *flipt.CreateVariantRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteConstraint provides a mock function with given fields: ctx, in, opts
func (_m *FliptClient) DeleteConstraint(ctx context.Context, in *flipt.DeleteConstraintRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *emptypb.Empty
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.DeleteConstraintRequest, ...grpc.CallOption) (*emptypb.Empty, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.DeleteConstraintRequest, ...grpc.CallOption) *emptypb.Empty); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emptypb.Empty)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *flipt.DeleteConstraintRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteDistribution provides a mock function with given fields: ctx, in, opts
func (_m *FliptClient) DeleteDistribution(ctx context.Context, in *flipt.DeleteDistributionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *emptypb.Empty
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.DeleteDistributionRequest, ...grpc.CallOption) (*emptypb.Empty, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.DeleteDistributionRequest, ...grpc.CallOption) *emptypb.Empty); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emptypb.Empty)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *flipt.DeleteDistributionRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFlag provides a mock function with given fields: ctx, in, opts
func (_m *FliptClient) DeleteFlag(ctx context.Context, in *flipt.DeleteFlagRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *emptypb.Empty
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.DeleteFlagRequest, ...grpc.CallOption) (*emptypb.Empty, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.DeleteFlagRequest, ...grpc.CallOption) *emptypb.Empty); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emptypb.Empty)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *flipt.DeleteFlagRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRule provides a mock function with given fields: ctx, in, opts
func (_m *FliptClient) DeleteRule(ctx context.Context, in *flipt.DeleteRuleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *emptypb.Empty
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.DeleteRuleRequest, ...grpc.CallOption) (*emptypb.Empty, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.DeleteRuleRequest, ...grpc.CallOption) *emptypb.Empty); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emptypb.Empty)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *flipt.DeleteRuleRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSegment provides a mock function with given fields: ctx, in, opts
func (_m *FliptClient) DeleteSegment(ctx context.Context, in *flipt.DeleteSegmentRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *emptypb.Empty
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.DeleteSegmentRequest, ...grpc.CallOption) (*emptypb.Empty, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.DeleteSegmentRequest, ...grpc.CallOption) *emptypb.Empty); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emptypb.Empty)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *flipt.DeleteSegmentRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteVariant provides a mock function with given fields: ctx, in, opts
func (_m *FliptClient) DeleteVariant(ctx context.Context, in *flipt.DeleteVariantRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *emptypb.Empty
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.DeleteVariantRequest, ...grpc.CallOption) (*emptypb.Empty, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.DeleteVariantRequest, ...grpc.CallOption) *emptypb.Empty); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emptypb.Empty)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *flipt.DeleteVariantRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Evaluate provides a mock function with given fields: ctx, in, opts
func (_m *FliptClient) Evaluate(ctx context.Context, in *flipt.EvaluationRequest, opts ...grpc.CallOption) (*flipt.EvaluationResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flipt.EvaluationResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.EvaluationRequest, ...grpc.CallOption) (*flipt.EvaluationResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.EvaluationRequest, ...grpc.CallOption) *flipt.EvaluationResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flipt.EvaluationResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *flipt.EvaluationRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFlag provides a mock function with given fields: ctx, in, opts
func (_m *FliptClient) GetFlag(ctx context.Context, in *flipt.GetFlagRequest, opts ...grpc.CallOption) (*flipt.Flag, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flipt.Flag
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.GetFlagRequest, ...grpc.CallOption) (*flipt.Flag, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.GetFlagRequest, ...grpc.CallOption) *flipt.Flag); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flipt.Flag)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *flipt.GetFlagRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRule provides a mock function with given fields: ctx, in, opts
func (_m *FliptClient) GetRule(ctx context.Context, in *flipt.GetRuleRequest, opts ...grpc.CallOption) (*flipt.Rule, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flipt.Rule
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.GetRuleRequest, ...grpc.CallOption) (*flipt.Rule, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.GetRuleRequest, ...grpc.CallOption) *flipt.Rule); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flipt.Rule)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *flipt.GetRuleRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSegment provides a mock function with given fields: ctx, in, opts
func (_m *FliptClient) GetSegment(ctx context.Context, in *flipt.GetSegmentRequest, opts ...grpc.CallOption) (*flipt.Segment, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flipt.Segment
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.GetSegmentRequest, ...grpc.CallOption) (*flipt.Segment, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.GetSegmentRequest, ...grpc.CallOption) *flipt.Segment); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flipt.Segment)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *flipt.GetSegmentRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFlags provides a mock function with given fields: ctx, in, opts
func (_m *FliptClient) ListFlags(ctx context.Context, in *flipt.ListFlagRequest, opts ...grpc.CallOption) (*flipt.FlagList, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flipt.FlagList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.ListFlagRequest, ...grpc.CallOption) (*flipt.FlagList, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.ListFlagRequest, ...grpc.CallOption) *flipt.FlagList); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flipt.FlagList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *flipt.ListFlagRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListRules provides a mock function with given fields: ctx, in, opts
func (_m *FliptClient) ListRules(ctx context.Context, in *flipt.ListRuleRequest, opts ...grpc.CallOption) (*flipt.RuleList, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flipt.RuleList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.ListRuleRequest, ...grpc.CallOption) (*flipt.RuleList, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.ListRuleRequest, ...grpc.CallOption) *flipt.RuleList); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flipt.RuleList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *flipt.ListRuleRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSegments provides a mock function with given fields: ctx, in, opts
func (_m *FliptClient) ListSegments(ctx context.Context, in *flipt.ListSegmentRequest, opts ...grpc.CallOption) (*flipt.SegmentList, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flipt.SegmentList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.ListSegmentRequest, ...grpc.CallOption) (*flipt.SegmentList, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.ListSegmentRequest, ...grpc.CallOption) *flipt.SegmentList); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flipt.SegmentList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *flipt.ListSegmentRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OrderRules provides a mock function with given fields: ctx, in, opts
func (_m *FliptClient) OrderRules(ctx context.Context, in *flipt.OrderRulesRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *emptypb.Empty
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.OrderRulesRequest, ...grpc.CallOption) (*emptypb.Empty, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.OrderRulesRequest, ...grpc.CallOption) *emptypb.Empty); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*emptypb.Empty)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *flipt.OrderRulesRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateConstraint provides a mock function with given fields: ctx, in, opts
func (_m *FliptClient) UpdateConstraint(ctx context.Context, in *flipt.UpdateConstraintRequest, opts ...grpc.CallOption) (*flipt.Constraint, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flipt.Constraint
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.UpdateConstraintRequest, ...grpc.CallOption) (*flipt.Constraint, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.UpdateConstraintRequest, ...grpc.CallOption) *flipt.Constraint); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flipt.Constraint)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *flipt.UpdateConstraintRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateDistribution provides a mock function with given fields: ctx, in, opts
func (_m *FliptClient) UpdateDistribution(ctx context.Context, in *flipt.UpdateDistributionRequest, opts ...grpc.CallOption) (*flipt.Distribution, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flipt.Distribution
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.UpdateDistributionRequest, ...grpc.CallOption) (*flipt.Distribution, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.UpdateDistributionRequest, ...grpc.CallOption) *flipt.Distribution); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flipt.Distribution)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *flipt.UpdateDistributionRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateFlag provides a mock function with given fields: ctx, in, opts
func (_m *FliptClient) UpdateFlag(ctx context.Context, in *flipt.UpdateFlagRequest, opts ...grpc.CallOption) (*flipt.Flag, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flipt.Flag
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.UpdateFlagRequest, ...grpc.CallOption) (*flipt.Flag, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.UpdateFlagRequest, ...grpc.CallOption) *flipt.Flag); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flipt.Flag)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *flipt.UpdateFlagRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateRule provides a mock function with given fields: ctx, in, opts
func (_m *FliptClient) UpdateRule(ctx context.Context, in *flipt.UpdateRuleRequest, opts ...grpc.CallOption) (*flipt.Rule, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flipt.Rule
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.UpdateRuleRequest, ...grpc.CallOption) (*flipt.Rule, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.UpdateRuleRequest, ...grpc.CallOption) *flipt.Rule); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flipt.Rule)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *flipt.UpdateRuleRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSegment provides a mock function with given fields: ctx, in, opts
func (_m *FliptClient) UpdateSegment(ctx context.Context, in *flipt.UpdateSegmentRequest, opts ...grpc.CallOption) (*flipt.Segment, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flipt.Segment
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.UpdateSegmentRequest, ...grpc.CallOption) (*flipt.Segment, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.UpdateSegmentRequest, ...grpc.CallOption) *flipt.Segment); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flipt.Segment)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *flipt.UpdateSegmentRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateVariant provides a mock function with given fields: ctx, in, opts
func (_m *FliptClient) UpdateVariant(ctx context.Context, in *flipt.UpdateVariantRequest, opts ...grpc.CallOption) (*flipt.Variant, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *flipt.Variant
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.UpdateVariantRequest, ...grpc.CallOption) (*flipt.Variant, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *flipt.UpdateVariantRequest, ...grpc.CallOption) *flipt.Variant); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flipt.Variant)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *flipt.UpdateVariantRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type mockConstructorTestingTNewFliptClient interface {
	mock.TestingT
	Cleanup(func())
}

// NewFliptClient creates a new instance of FliptClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewFliptClient(t mockConstructorTestingTNewFliptClient) *FliptClient {
	mock := &FliptClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
